## 스프링의 핵심

: 자바 기반 프레임워크 ⇒ 자바의 핵심 : 객체 지향 언어

** 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

이전 EJB를 사용할 당시에는 EJB에 종속되어 객체 지향의 좋은 점을 상실해버렸다.

⇒ 스프링의 등장 이유
<br><br>

## 좋은 객체 지향 프로그래밍이란?

객체 지향의 특징 : 추상화 캡슐화 상속 다형성 …

 ⇒ 이로 인해 코드를 마치 부품을 교체하듯이 쉽고 유연하게 변경할 수 있다.

이 중 궁극의 유연성, 변경성을 보장해주는 특징이 바로 다형성이다.

다형성의 핵심은 세상을 역할과 구현으로 나누어 보는 것이다.

운전을 예시로 운전을 운전자의 역할과 자동차의 역할 두 가지로 나누어 보자

자동차의 역할에 대한 구현으로 현기차나 테슬라 같은 여러 차들을 구현할 수 있다.

차가 어떠한 기종으로 바뀌어도 운전자는 아무 문제 없이 운전할 수 있다.

즉, 클라이언트인 운전자가 자동차가 어떤 기종으로 구형됐는지 신경쓰지 않고도 운전을 할 수 있다.

운전자는 자동차가 차의 역할을 지켜주기만 한다면 어떤 기종이든 운전할 수 있다. 차가 바뀌어도 운전자가 바뀔 필요가 없다는 것이다.

이것이 가능한 이유는 세상을 역할과 구현이라는 체계로 분리했기 때문이다.

즉, 다형성을 통해 클라이언트가 대상을 사용할 때 그 대상의 인터페이스만 알고 있으면 그 인터페이스를 만족하는 어떠한 객체도 그 객체의 구조를 알 필요없이 사용할 수 있고 그 과정에서 클라이언트의 변경도 필요없게 되는 것이다. 이게 객체 지향의 특징인 유연하고 변경에 용이하다는 것의 의미이다.

중요한 점은 역할이, 인터페이스가 변경된다면 많은 것이 바뀌게 된다는 것이다. 차의 역할이 바뀌게 되면 차도 운전자도 많은 변화가 필요하게 된다. 그러므로 인터페이스를 안정적으로 설계하는 것이 중요하다.

스프링은 이런 다형성을 극대화해서 사용할 수 있게 도와주는 것이 핵심 기능이다.

IoC, DI 등의 기능 또한 마찬가지로 다형성을 최대한으로 사용할 수 있도록 지원하는 기능인 것이다.
<br><br>

## 좋은 객체 지향 설계의 5가지 원칙 : SOLID

단일 책임 원칙 : Single Responsibility Principle

: 한 클래스는 하나의 책임만 가져야 한다

⇒ 변경이 있을 때 파급이 적으면 잘 적용된 것
<br><br>

개방 폐쇄 원칙 : Open Closed Principle

: 소프트웨어 요소는 확장에 열려 있고 변경에는 닫혀야 한다

다형성을 사용해도 결국 클라이언트의 코드를 변경해야 한다

⇒ 이를 보완해주는 별도의 조립, 설정자가 필요하다 : DI 컨테이너
<br><br>

리스코프 치환 원칙 : Liskov Substitution Principle

: 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 잇어야 한다.

⇒ 단순히 컴파일 여부를 넘어 기존 기능을 위배하지 않고 치환 가능하야 한다
<br><br>

인터페이스 분리 원칙 : Interface Segregation Principle

: 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다

⇒  인터페이스가 너무 범용적이면 한 클라이언트의 변경이 다른 클라이언트에 영향을 줌

ex) 자동차 인터페이스 ⇒ 운전 인터페이스 + 정비 인터페이스
<br><br>

의존 관계 역전 원칙 : Dependemcy Inversion Principle

: 구현체에 의존하지 말고 추상체에 의존해야 한다

⇒ 구현 클래스에 의존하지 말고 인터페이스에 의존해야 한다

다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 변경된다

⇒ 다형성만으로는 OCP, DIP 를 지킬 수 없다
<br><br>

## 객체 지향 설계와 스프링

스프링은 다형성과 OCP, DIP를 지킬 수 있도록 기능을 지원한다

⇒ DI, DI 컨테이너

** 클라이언트 코드의 변경없이 기능 확장 가능
<br><br>

## AppConfig 구현으로 적용한 SOLID 원칙
<img width="100%" src="https://github.com/phwGithub/SpringCoreBasic/assets/116074334/d0af69ea-5308-450b-83a7-35fa3ff8f10a"/>

1. SRP : 단일 책임 원칙
- 인터페이스뿐만아니라 구현 클래스까지 알아야 했던 기존 코드에서 객체 선정의 역할을 AppConfig가 가져감으로 관심사를 분리할 수 있었다
- 클라이언트는 이제 실행하는 책임만 담당할 수 있게 되었다
<br><br>

1. DIP : 의존관계 역전 원칙
- 클라이언트가 인터페이스만 의존하게 됨에 따라 실행시킬 구현 클래스를 누군가가 만들어줄 필요가 생겼다
- 이 구현 클래스 생성을 AppConfig가 대신 만들어줌으로서 DIP 를 만족하면서도 실행할 수 있는 코드가 되었다
<br><br>
1. OCP : 확장-폐쇄 원칙
- 상기의 사항들로 인해 이제 새로운 할인 정책으로 변경이 필요해도 클라이언트 코드는 변경할 필요 없이 AppConfig에서 다른 객체를 생성하도록 하기만 하면 손쉽게 변경이 가능하다
- 즉, 확장에는 열려있고 변경에는 닫혀있도록 하는 OCP 원칙 또한 자연스럽게 만족하였다
<br><br>

## IoC, DI, Container

**IoC**

IoC(Inversion of Control)는 ‘제어의 역전’이라는 뜻이며 프레임워크와 라이브러리를 구분하는 프레임워크의 핵심 기능이다. 보통의 프로그래밍에서는 객체의 생성과 연결을 개발자 본인이 담당하며 이는 제어의 흐름이 개발자에게 있다는 의미이다. 제어의 역전이란, 즉, 이 제어권을 개발자에게서 프레임워크로 가져온다는 뜻이 된다. 쉽게 말해, IoC가 적용된 프레임워크에서는 객체의 생성과 연결은 프레임워크가 담당하고 개발자는 실행 로직만 개발할 수 있게 된다. 

AppConfig의 예를 들면 주문 시 OrderServiceImpl 을 사용하게 되는데 이 때 어떤 MemberRepository를 사용할 지, 어떤 DiscountPolicy를 사용할 지는 모두 AppConfig가 담당하게 되고 OrderServiceImpl 에서는 주문 로직에 해당하는 부분만 생각할 수 있게 된다. 

Junit 프레임워크의 경우도 마찬가지이다. Junit 을 사용할 때 사용자는 객체의 생성의 대한 부분은 전혀 고려하지 않는다. 그저 테스트 메소드에 대한 로직만 개발하고 객체 생성과 실행은 Junit 프레임워크에 일임한다.

이처럼 객체의 생성과 연결에 관한 흐름을 대신 담당하는 것이 라이브러리와 다른 프레임워크의 특징이라 할 수 있겠다. 이렇게 IoC 를 사용해서 얻게 되는 이득이 무엇인지는 아래 DI 설명에서 후술하겠다.
<br><br>

**DI**

DI(Dependency Injection)는 ‘의존관계 주입’이라는 뜻이며 동적으로, 즉, 런타임에 의존관계를 연결하는 것을 의미한다. 의존관계는 정적 의존관계와 동적 의존관계로 구분된다. 정적 의존관계는 프로그램을 실행하지 않아도 알 수 있는 의존관계이며 보통 클래스 다이어그램으로 표현될 수 있다. SOLID에 의거한 객체 지향 프로그래밍에서는 클래스는 인터페이스에만 의존하기 때문에 정적 의존관계, 클래스 의존관계만으로는 어떤 객체가 주입될 지 알 수 없다. 동적 의존관계는 프로그램 실행 시 실제로 생성된 객체 인스턴스가 어떻게 연결되어 있는 지 보여주는 관계도를 말한다. 예시 코드를 들어 설명하면 실제 사용된 Member Repository가 메모리인지 Jdbc인지, DiscountPolicy가 정액 할인인지 정률 할인인지를 나타내는 의존관계를 말한다.

의존관계 주입이란 다시 말해 런타임에 실제 동적 의존관계가 연결되는 것을 말한다. 즉, 어떤 DB를 사용할 지, 어떤 할인정책을 사용할 지를 프레임워크에서 담당해서 런타임에 주입시켜 주는 것이다.

DI를 사용해서 얻는 이점은 정적 의존관계를 변경하지 않고, 즉, 클라이언트 코드를 변경하지 않고 동적인 객체 인스턴스의 관계를 쉽게 변경할 수 있다는 점이다. 예시 코드처럼 AppConfig만 살짝 수정하면 기존 코드에 어떤 코드도 변경할 필요없이 할인 정책을 바꾸거나 DB를 변경할 수 있다. 이것이 바로 DI가, 그리고 DI를 위해 IoC가 필요한 이유이다.
<br><br>

**DI(or IoC) Container**

객체를 생성하고 의존관계를 동적으로 연결시켜 주는 AppConfig와 같은 담당자를 IoC 컨테이너, 또는 DI 컨테이너라고 한다.
<br><br>

## 웹 애플리케이션과 싱글톤

스프링은 태생적으로 기업용 온라인 서비스를 지원하기 위해 만들어진 프레임워크이다. 즉, 스프링은 주로 웹 애플리케이션으로 많이 활용된다. 웹 애플리케이션에서는 보통 여러 고객이 동시에 요청하는 경우가 많다. 예제로 만들어 본 순수 DI 컨테이너(AppConfig)에서는 조회할 때마다 memberService가 만들어진다. 즉, 요청이 있을 때마다 그 요청 수 만큼의 인스턴스가 만들어진다는 얘기이다. 이로 인해 많은 메모리 낭비가 생기고 서비스에 문제가 발생할 수 있다. 이에 대한 해결책으로 **싱글톤 패턴**을 적용하여 사용하여 객체를 하나만 만들고 이름 공유함으로서 해결하도록 했다.
<br><br>

## 싱글톤 패턴

<img width="100%" src="https://github.com/phwGithub/SpringCoreBasic/assets/116074334/344e4cba-d14f-4ba6-868c-e7949c6d45a3">

싱글톤 패턴을 적용하는 가장 직관적인 방법은 위 코드와 같이 static으로 객체를 하나 선언하고 그 객체를 반환하는 메소드를 만들어 제공하는 것이다. 이 때 중요한 것은 생성자를 private로 선언하여 다른 곳에서 new 키워드로 객체를 생성할 수 없도록 하는 것이다. 이렇게 간단하게 싱글톤 패턴을 구현하여 오직 하나만의 객체를 만들어 공유할 수 있다. 하지만 이 싱글톤 패턴에서는 여러 단점 또한 존재한다.

1. 싱글톤 패턴을 구현하는 코드를 계속 만들어야 하고
2. 클라이언트가 구체 클래스에 의존하며 → DIP 위반 ex) SingletonService(알아야함).getInstance();
3. 이로 인해 OCP 또한 지켜지기 어려우며
4. 테스트가 어렵다

등등 결론적으로 매우 유연성이 떨어지는 패턴이라 할 수 있다. 스프링에서는 아래와 같은 방법으로 이와 같은 단점들을 보완하면서 싱글톤 패턴을 적용했다.
<br><br>

## 싱글톤 컨테이너

스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서 객체 인스턴스를 싱글톤으로 관리한다. 스프링 컨테이너는 기본적으로 스프링 빈을 사용하며 빈이 등록될 때 하나의 객체를 만들어 빈 이름과 매칭한다. 즉, 스프링 컨테이너는 싱글톤 컨테이너의 역할 또한 자연스럽게 수행하고 있는 것이다. 이로 인해 싱글톤 패턴의 단점이었던 구현 코드를 계속 작성해야 했던 것과 DIP, OCP를 위반하던 사항들을 해결하면서 싱글톤 패턴을 적용할 수 있게 된 것이다. 그럼에도 싱글톤 방식을 사용하는데에는 몇 가지 주의점이 필요한다.
<br><br>

## 싱글톤 방식의 주의점

싱글톤 패턴, 싱글톤 컨테이너와 같이 하나의 객체를 여럿이 공유하는 경우, 싱글톤 객체는 무조건 stateless 하게 설계해야 한다. 즉, 특정 클라이언트에 의존적이거나 특정 클라이언트가 값을 변경할 수 있는 공유 필드가 존재해서는 안되며 가급적 지역변수를 통해 처리해야 한다. 만약 그렇지 못한다면 한 클라이언트가 다른 클라이언트의 값을 무단으로 확인하거나 변경할 수 있게 된다. 몇년에 한번씩은 나오는 해결하기 어려운 문제라고 한다.
<br><br>

## @Configuration과 싱글톤

AppConfig 코드를 보면 이상한 점이 있다.  orderService 메소드에서 OrderServiceImpl을 생성할 때 memberRepository를 한번 더 호출한다. 이 경우 MemoryMemberRepository가 2번 호출되어 싱글톤이 깨질 것이 우려된다. 하지만 테스트를 통해 이를 확인해보면 둘 다 같은 인스턴스를 사용하고 있는 것이 확인된다. 이는 어떻게 가능한 것인가?  @Configuration에 이 비밀이 있다.

테스트를 통해 AppConfig 이름으로 만들어진  빈 이름을 확인해보면 AppConfig$$xxxxCGLIB$$가 붙은 이상한 빈이 나오는 것을 확인할 수 있다. 이는 스프링이 바이트코드를 조작하여 만들어낸 AppConfig를 상속받은 새로운 객체이다. 이 객체에서 어떤 빈을 만들 때 이미 등록된 빈을 만들려 한다면 스프링 컨테이너에서 찾아서 반환해준다. 이를 통해 중복으로 빈이 만들어지는 상황을 방지하고 싱글톤임을 보장해주는 것이다.
<br><br>

## 다양한 의존관계 주입 방법

1. 생성자 주입

생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다. ⇒ 불변 : 외부에서 변경할 수단이 없음

객체 생성 시 호출 되기 때문에 호출 시점에 의존 관계가 주입된다.

생성자가 하나일 때 Autowired 필요없음
<br><br>

1. 수정자 주입

setter라 불리는 수정자 메소드를 통해 주입하는 방법 ⇒ 선택, 변경 가능

Bean 생성이 끝난 후 의존관계가 주입됨

Autowired 필수
<br><br>

1. 필드 주입

필드에 바로 어노테이션을 적어 주입하는 방법

외부에서 변경할 수 없어서 테스트가 힘들다는 점 때문에 권장하지 않는 방법

DI 프레임워크를 거치지 않으면 아무 테스트를 할 수 없다 ⇒ 되도록 사용하지 말자
<br><br>

1. 일반 메서드 주입

일반 메서드를 통해서 주입 받는 방법 ⇒ 이것도 잘 사용하지 않음

한 번에 여러 필드를 주입할 수 있다
<br><br>
 

** Autowired는 스프링 빈이여야만 동작한다
<br><br>

## 생성자 주입을 선택하라

이유 1 : 불변

대부분의 의존관계 주입은 한번 일어나면 종료 시점까지 의존관계를 변경하지 않고 오히려 변경하지 않아야 하는 경우가 많다. 또한 수정자 메서드를 사용하게 되면 이 메소드를 public하게 둬야 하는데 이 경우 누군가의 실수로 인해 의도치 않게 의존관계가 변경될 확률이 높다. 이는 좋은 설계 방법이라 할 수 없다.
<br><br>

이유 2 : 누락

프레임워크 없이 순수한 자바 코드로 단위 테스트를 할 때, 수정자 메서드의 경우 의존관계 주입할 대상을 누락할 수 있는 가능성이 있다. 반면에 생성자의 경우 코드 작성 시 컴파일 오류를 내기 때문에 이런 누락에 대한 가능성을 없앨 수 있다.
<br><br>

이유 3 : final 키워드 사용

생성자 주입을 하면 final 키워드를 사용할 수 있고 혹시라도 생성자에서도 누락할 수 있는 가능성을 컴파일 오류로 잡아준다. 나머지 주입 방식은 final 키워드를 사용할 수 없다.
<br><br>
** 컴파일 오류는 가장 빠르고 좋은 오류라는 것을 기억하자
<br><br>

## 조회된 빈이 2개 이상일 때 처리 방법

@Autowired는 기본적으로 타입으로 조회한다. 즉, 같은 타입을 상속받은 객체들은 조회될 때 모두 조회된다는 의미이다. 결국 개발자는 이 중 하나를 선택해서 주입해야 하기 때문에 어떤 빈을 주입할 지를 정해주어야한다.
<br><br>

해결 1 : @Autowired 필드명

빈이 중복된다면 주입할 멤버 변수의 필드명을 찾아서 자동으로 주입해준다. 즉, 원하는 빈에 매칭되는 필드명을 작성하면 그 빈으로 자동 주입된다.
<br><br>

해결 2 : @Qualifier

중복이 우려되는 컴포넌트에게 직접 이름을 부여한다 ex) @Qualifier(”…”)

그 후, 주입할 매개 변수 옆에 @Qualifier(”…”) 를 작성해주면 ex) @Qualifier("…") DiscountPolicy …

그 Qualifier 이름에 해당하는 빈을 주입해준다.
<br><br>

해결 3 : @Primary

중복이 우려되는 컴포넌트 중 우선적으로 주입하고 싶은 컴포넌트에게 @Primary를 작성하면 그 빈이 자동으로 입력된다.
<br><br>

** Primary와 Qualifier가 충돌할 때는 더 상세한 작성이 필요한 Qualifier쪽이 우선권을 갖는다. 스프링은 기본적으로 더 디테일한 작성이 필요한 쪽, 즉, 자동보다 수동에 우선권을 준다는 것을 기억하자
<br><br>

## 자동, 수동의 올바른 실무 운영 기준

— 편리한 자동 기능을 기본적으로 사용하자

스프링이 나오고 시간이 갈 수록 점점 자동을 선호하는 추세이다. 빈을 하나하나 추가할 때마다 설정 정보에 가서 일일이 @Bean으로 등록하는 과정은 상당히 번거롭다. 그리고 근본적으로 자동으로 빈을 등록해도 OCP, DIP를 위반하지 않기 때문에 자동 빈을 사용하는 것이 합리적이다.
<br><br>

— 수동 빈 등록은 언제 사용하는게 좋을까

비즈니스 영역에서 사용하는 controller, service 같은 뻔한, 패턴이 있는 작업들은 그 수도 많고 문제가 발생하는 곳이 명확하기 때문에 자동을 사용하는 것이 좋지만 데이터 베이스 연결, 공통 로그 처리 같은 기술 지원 영역에 대한 빈들은 그 수가 적을 뿐더러 광범위한 곳에 영향을 미치기 때문에 수동 빈을 사용해서 이들이 사용되는 곳을 명확히 하는 것이 좋다.<br>

또 비즈니스 영역에서도 다형성을 적극적으로 활용할 때, 예를 들어, 빈을 Map이나 List로 받아올 경우 이것들은 따로 수동으로 만들어두어 이 안에 어떤 것들이 있는지 한눈에 알아볼 수 있도록 하는 것이 바람직하다. 정 자동으로 등록하고 싶다면 이들을 같은 패키지에 놓는 것이 좋다. 요는 어떤 방식이던 한눈에 파악할 수 있도록 해두는 것이다.
<br><br>

**정리**

1. 편리한 자동 기능을 기본으로
2. 직접 등록하는 기술 지원 객체는 수동 등록
3. 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고려
<br><br>

## 빈 생명주기 콜백 시작

애플리케이션 시작 지점에 필요한 연결을 미리 해두고 애플리케이션 종료 시점에 연결을 모두 종료하는 작업이 필요할 때가 있다. 주로 데이터베이스 커넥션 풀이나 네트워크 소켓같은 작업들이 이에 속한다. 스프링 빈은 크게 객체 생성 → 의존관계 주입의 생명주기를 가지는데 이것이 다 끝나기 전에 위와 같은 작업을 수행할 경우 뜻하는 결과가 나오지 않게 된다. 이를 위해서 스프링에서는 의존관계 주입이 다 끝났을 시점과 이 스프링 컨테이너의 종료 시점에 콜백을 주도록 하였다. 이를 포함한 스프링 빈의 이벤트 라이프 사이클은 다음과 같다.
<br><br>
스프링 컨테이너 생성→스프링 빈 생성→의존관계 주입→초기화 콜백→사용→소멸 전 콜백→스프링 종료
<br><br>
** 객체의 생성과 초기화를 분리하는 것이 좋다. 초기화에는 외부 커넥션을 연결하는 등 무거운 작업들이 진행되기 때문에 생성과 초기화를 분리하는 것이 유지보수 관점에서 좋은 방법이다.
<br><br>
스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.
<br><br>
1. 인터페이스(InitializingBean, DisposableBean)
    - 스프링 전용 인터페이스라 외부 라이브러리에  적용하지 못하고 초기화, 소멸 메소드의 이름도 변경할 수 없다.
    - 초창기에 나온 방법이라 현재는 거의 사용하지 않는다.
<br><br>    
2. 설정 정보에 초기화 메서드, 종료 메서드 지정
    - 메서드 이름을 자유롭게 변경할 수 있고 외부 라이브러리에도 적용 가능하다.
    - 종료 메서드 추론이라는 기능을 통해 종료 메서드 이름을 close, shutdown으로 만들어 두면 일부러 작성하지 않아도 자동으로 실행해준다.
<br><br>  
3. @PostConstruct, @PreDestroy 애노테이션 지원 **
    - 최신 스프링에서 권장하는 방법
    - 매우 편리하고 java 표준에서 제공하는 방법이라 스프링이 아닌 다른 컨테이너에서도 작동한다.
    - 유일한 단점은 외부 라이브러리에 적용할 수 없다. 이 경우 설정 정보 방식을 사용하자
<br><br>
## 빈 스코프

빈 스코프란 말 그대로 빈이 존재할 수 있는 범위를 의미한다. 기본적으로 빈은 싱글톤 빈이고 싱글톤 빈은 스프링 컨테이너가 소멸할 때까지 유지된다. 스프링은 다양한 스코프를 지원한다.
<br><br>
1. 싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
2. 프로토타입 : 생성과 의존관계까지만 컨테이너가 관여하고 그 뒤는 관리하지 않는 짧은 범위의 스코프
3. 웹 관련 스코프
    - request : 웹 요청이 들어오고 나갈 때까지 유지되는 스코프
    - session : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프
    - application : 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프
<br><br>
## 프로토타입 스코프

**특징**
<br><br>
- 스프링 컨테이너에 요청될 때마다 생성됨
- 스프링 컨테이너는 빈의 생성, 주입, 초기화까지만 관여함, 종료 메서드는 호출하지 않음
- 프로토타입 빈을 조회한 클라이언트가 빈을 관리해야함
<br><br>

**싱글톤 빈과 함께 사용할 시 주의점**
<br><br>
싱글톤에 프로토타입 빈을 주입해서 사용할 경우 싱글톤 빈이 생성될 때 프로토타입 빈을 주입받고 다시 싱글톤 빈이 호출되더라도 맨 처음 주입받은 프로토타입 빈을 사용하게 된다. 이는 요청받을 때마다 새로 생성하게 하려는 프로토타입의 의도와는 틀린 방식이기 때문에 다른 방법이 필요하다.
<br><br>

**싱글톤 빈과 함께 사용할 시 발생하는 문제 해결법**
<br><br>
가장 단순하게 싱글톤 빈 생성 시마다 컨테이너에서 생성받아 주입할 수 있다. 이렇게 하면 컨테이너에 종속적이고 단위 테스트도 어려워 좋은 방법은 아니다. 이렇게 주입받는게 아니라 의존관계를 찾아 넣는 것을 Dependency Lookup(DL)이라고 하는데 이것만 해줄 수 있는 방법이 바로 ObjectProvider이다.
프로토타입 빈을 주입받는 대신 ObjectProvider를 선언해 getObject로 가져오면 provider가 대신 DL해서 프로토타입 빈을 요청 시마다 생성해준다. 대신 이 방법은 스프링에 의존적이다. 대안으로 나온 것이 javax.inject 의 Provider이다. 작동 방식은 ObjectProvider와 같다.
<br><br>
** Provider는 프로토타입 뿐만아니라 DL이 필요한 어느 곳에서도 사용할 수 있다.
<br><br>
## 웹 스코프

웹 환경에서만 동작하며 프로토타입과 달리 종료 시점까지 관리하는 스코프
<br><br>
1. request : HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프, 요청마다 별도의 빈 생성
2. session : HTTP Session과 동일한 생명주기를 가지는 스코프
3. application : 서블릿 컨텍스트와 동일한 생명주기를 가지는 스코프
4. websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프
<br><br>
